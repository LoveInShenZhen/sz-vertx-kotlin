app {

  httpServer {
    port = 9000
    host = "0.0.0.0"
    // productionMode 为 true 表示工作在生产环境, 为 false 表示工作在开发环境
    productionMode = false

    initialSettings = {
      "headerTableSize": 4096,
      "initialWindowSize": 65535,
      "maxConcurrentStreams": 100,
      "maxFrameSize": 16384,
      "maxHeaderListSize": 2147483647,
      "pushEnabled": true
    }

    bodyHandler {
      bodyLimit = 100000
      uploadsDirectory = "file_uploads"
      mergeFormAttributes = false
      deleteUploadedFilesOnEnd = true
    }

    dispatcher {
      factory = "sz.scaffold.dispatchers.VertxWorkerPoolDispatcher"
    }

    httpOptions {
      // 请参考 HttpServerOptionsConverter.fromJson(...) 方法, 添加配置选项
    }

    networkOptions {
      // http://www.vants.org/?post=210
      tcpFastOpen = true
      // http://www.itdaan.com/blog/2017/11/08/18a176a9e1b6bca4a9cbe36b5070876c.html
      tcpCork = true
      // https://blog.csdn.net/bin_linux96/article/details/53141799
      tcpQuickAck = false
      // https://blog.csdn.net/u012398613/article/details/52317464
      reusePort = true
    }

    webSocket {
      // 是否由 server 端自动向连接的客户端发起ping操作
      autoPingByServer = true
      // websocket 为了维护长连接, 服务器端自动向客户端ping的时间间隔, 单位: 毫秒
      pingInterval = 30000

      // the maximum webSocket frame size in bytes. default: 64 KB (65536 Bytes)
      maxWebSocketFrameSize = 65536
      // Default max WebSocket message size (could be assembled from multiple frames) is 4 full frames worth of data.
      // default is 65536 * 4 (256 KB)
      maxWebSocketMessageSize = 262144
    }

    // 全局拦截器, 所有的请求都会经过指定的拦截器进行处理
    // 拦截器的顺序与列表的顺序相同
    // 全局拦截器从 sz.scaffold.aop.interceptors.GlobalInterceptorBase 基类基础
    interceptors = [
//      {
//        className = "todo: 放上拦截器的类名"
//        config = {}
//      },
//      {
//        className = "todo: 放上拦截器的类名"
//        config = {}
//      },
    ]
  }

  vertx {
    options {
      clustered = false
      workerPoolSize = 16
      preferNativeTransport = true
    }

    zookeeper {
      // zookeeper 主机， 多个主机配置方式, 例如： "zooServer_1:2181,zooServer_2:2181,zooServer_3:2181"
      zookeeperHosts = "localhost:2181"
      sessionTimeout = 20000
      connectTimeout = 3000
      rootPath = "io.vertx"
      retry {
        initialSleepTime = 100
        intervalTimes = 10000
        maxTimes = 5
      }
    }
  }
}

redis {

  globalConfig {
    // redis密码是否要求加密, 默认为 false, 密码为明文
    encryptPasswd = false

    // 当 encryptPasswd = true 的时候, redis的密码将使用 Rsa 加密
    // 所以需要指定用于解密的私钥文件
    privateKeyFile = "conf/privateKey.pem"
  }

  servers {

    default {
      // 工作模式: STANDALONE, SENTINEL, CLUSTER, 默认为: STANDALONE 模式
      workingMode = "STANDALONE"
      // 当工作模式为 SENTINEL 和 CLUSTER, 会根据 servers 配置来创建 redisClient
      // eg:
      // SENTINEL 时: servers = ["SENTINEL_1:port", "SENTINEL_2:port", "SENTINEL_3:port"]
      // CLUSTER 时: servers = ["Redis_1:port", "Redis_2:port", "Redis_3:port"]
      servers = []
      // 当工作模式为: SENTINEL 时, 还需要设置 masterName, 这个需要和 sentinel.conf 配置的一致
      masterName = "redis_master"
      // 默认连接本地的 redis server
      host = "localhost"
      port = 6379
      // this is connection timeout in ms
      timeout = 2000
      database = 0
      netClientOptions {
        reusePort = true,
        tcpNoDelay = true,
        tcpKeepAlive = true,
        tcpFastOpen = false,
        tcpQuickAck = true,
        connectTimeout = 2000
      }
      ssl = false
      password = ""

      // 如果其他的 Redis 数据连接配置,没有指定pool配置, 则默认使用与 redis.servers.default.pool 相同的配置
      pool {
        // 基本参数

        // 数量控制参数
        // 链接池中最大连接数,默认为8
        maxTotal = 8
        // 链接池中最大空闲的连接数,默认也为8
        maxIdle = 8
        // 连接池中最少空闲的连接数,默认为2
        minIdle = 2

        // 驱逐检测的间隔时间, 默认10分钟
        timeBetweenEvictionRunsSeconds = 600

        // 超时参数
        // 从对象池里借对象时的超时时间, 拍脑袋决定默认值 5000 ms
        // 设置为 0 或者负数的时候, 表示不进行超时控制
        borrowTimeoutMs = 5000

        // 额外参数
        operationTimeout = -1
      }

    }
  }

}